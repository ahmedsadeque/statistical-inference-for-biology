---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 08-matrix-notation.md in _episodes_rmd/
title: "Matrix Algebra Notation"
teaching: 0
exercises: 0
questions:
- "?"
- "?"
- "?"
objectives:
- ""
- ""
- ""
- ""
- ""
- ""
- ""
keypoints:
- "."
- "."
- "."
- "."
source: Rmd
---



## Matrix Notation

Here we introduce the basics of matrix notation. Initially this may seem over-complicated, but once we discuss examples, you will appreciate the power of using this notation to both explain and derive solutions, as well as implement them as R code. 

#### The language of linear models

Linear algebra notation actually simplifies the mathematical descriptions and manipulations of linear models, as well as coding in R. We will discuss the basics of this notation and then show some examples in R.

The main point of this entire exercise is to show how we can write the models above using matrix notation, and then explain how this is useful for solving the least squares equation. We start by simply defining notation and matrix multiplication, but bear with us since we eventually get back to the practical application.

## Solving Systems of Equations

Linear algebra was created by mathematicians to solve systems of linear equations such as this:

![](../fig/03-system-linear-equations.png)

It provides very useful machinery to solve these problems generally. We will learn how we can write and solve this system using matrix algebra notation:

![](../fig/03-matrix-alg-notation.png)

This section explains the notation used above. It turns out that we can borrow this notation for linear models in statistics as well.

## Vectors, Matrices, and Scalars

In the falling object, father-son heights, and mouse weight examples, the random variables associated with the data were represented by <i>&Upsilon;<sub>i</sub>,...,<i>&Upsilon;<sub>n</sub></i>. We can think of this as a vector. In fact, in R we are already doing this:


~~~
data(father.son,package="UsingR")
y=father.son$fheight
head(y)
~~~
{: .language-r}



~~~
[1] 65.04851 63.25094 64.95532 65.75250 61.13723 63.02254
~~~
{: .output}
In math we can also use just one symbol. We usually use bold to distinguish it from the individual entries:

![](../fig/03-boldy-matrix-not.png)

For reasons that will soon become clear, default representation of data vectors have dimension <i>N x 1</i> as opposed to <i>1 x N</i>.

Here we don't always use bold because normally one can tell what is a matrix from the context.

Similarly, we can use math notation to represent the covariates or predictors. In a case with two predictors we can represent them like this:

![](../fig/03-two-bold-X-predictors.png)

Note that for the falling object example <i>x<sub>1,1</sub> = t<sub>i</sub></i> and <i>x<sub>i,1</sub> = t<sub>i</sub> &sup2;</i> with <i>t<sub>i</sub></i> the time of the <i>i</i>-th observation. Also, keep in mind that vectors can be thought of as <i>N x 1</i> matrices.

For reasons that will soon become apparent, it is convenient to represent these in matrices:

![](../fig/03-N-times-2-matrix-of-Xes.png)

This matrix has dimension <i>N x 2</i>. We can create this matrix in R this way:


~~~
n <- 25
tt <- seq(0,3.4,len=n) ##time in secs, t is a base function
X <- cbind(X1=tt,X2=tt^2)
head(X)
~~~
{: .language-r}



~~~
            X1         X2
[1,] 0.0000000 0.00000000
[2,] 0.1416667 0.02006944
[3,] 0.2833333 0.08027778
[4,] 0.4250000 0.18062500
[5,] 0.5666667 0.32111111
[6,] 0.7083333 0.50173611
~~~
{: .output}



~~~
dim(X)
~~~
{: .language-r}



~~~
[1] 25  2
~~~
{: .output}

We can also use this notation to denote an arbitrary number of covariates with the following <i>N x p</i> matrix:

![](../fig/03-N-times-p-matrix-of-Xes.png)

Just as an example, we show you how to make one in R now using `matrix` instead of `cbind`:


~~~
N <- 100; p <- 5
X <- matrix(1:(N*p),N,p)
head(X)
~~~
{: .language-r}



~~~
     [,1] [,2] [,3] [,4] [,5]
[1,]    1  101  201  301  401
[2,]    2  102  202  302  402
[3,]    3  103  203  303  403
[4,]    4  104  204  304  404
[5,]    5  105  205  305  405
[6,]    6  106  206  306  406
~~~
{: .output}



~~~
dim(X)
~~~
{: .language-r}



~~~
[1] 100   5
~~~
{: .output}

By default, the matrices are filled column by column. The `byrow=TRUE` argument lets us change that to row by row:


~~~
N <- 100; p <- 5
X <- matrix(1:(N*p),N,p,byrow=TRUE)
head(X)
~~~
{: .language-r}



~~~
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    2    3    4    5
[2,]    6    7    8    9   10
[3,]   11   12   13   14   15
[4,]   16   17   18   19   20
[5,]   21   22   23   24   25
[6,]   26   27   28   29   30
~~~
{: .output}

Finally, we define a scalar. A scalar is just a number, which we call a scalar because we want to distinguish it from vectors and matrices. We usually use lower case and don't bold. In the next section, we will understand why we make this distinction.
